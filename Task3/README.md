# ЗАДАНИЕ 3

Задание 2.
Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн. заказов некоторого сервиса
доставки еды за некоторый период 2021 и 2022 года.
Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента, а
средняя длина полного имени - 20 символов (латинских или кириллических).
Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента. Но вы не
хотите оставлять следы на диске или в базе данных - придется все держать в памяти. Но еще вы не хотите зря тратить
крипту на слишком большой сервер.
Поэтому давайте оценим, сколько памяти займут эти данные:

 если мы хотим реализовать поиск за постоянное время, т.е. O(1)?

 если мы хотим занять как можно меньше памяти?

Самое главное - объяснить, как вы пришли к той или иной числовой оценке.
Можно выбрать любой язык программирования/платформу

# Выбор структуры данных
Так как вводится условие - поиск за константное время - мы неизбежно сталкиваемся с необходимостью
использовать хеш-таблицы, поскольку только эта структура предоставляет возможность поиска за постоянное время.

### Решение коллизий
Так как размер базы увеличиваться не будет, нет необходимости использовать более стабильный, но
медленный метод цепочек, при котором время поиска будет зависеть от размерности групп. Коэффициент
заполнения вполне может быть >=1, но после нахождения элемента придется перебирать список.
Хотя и использование открытой адресации связано с большими затратами на размер таблицы, все же этот
способ предпочтительнее, лучше воспользоваться именно методом двойного хеширования.
### Определение размерности таблицы
Для того чтобы метод двойного хеширования работал стабильно быстро (за время **O(N)**)
необходимо, чтобы коэффициент заполнения не превышал 2/3 (возьмем лучший коэффициент заполнения 0.5, но мы не
обладаем точными сведениями, поэтому не критично, если таблица заполнится больше, чем на половину), и чтобы размер таблицы
был простым числом (в этом случае последовательность проб рано или поздно проверит все ячейки).
Нам нужен размер таблицы в 18 758 328*2=37 516 656. Берем ближайшее просто число - 37 516 667

# Ответ на первый вопрос
11 символов номера телефона + 20 символов имени =31 символ*2 байта=62 байта. Размерность массива
37 516 667. Каждый объект имеет оверхед в 8 байт+ ссылка 4 байта+ оверхед на сам массив -4 байта.
Размер одного элемента массива - 74 байта, что не кратно 8 и нуждается в округлении - 80 байт.
37 516 667 * 80 +4=3 001 333 360 байт или 3ГБ в памяти займет хранение такой структуры.
