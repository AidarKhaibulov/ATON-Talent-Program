### ЗАДАНИЕ 1:
In memory simple DB
В процессе реализации сервиса проверки данных возникла необходимость в
организации
in memory кэша с возможностью быстрого поиска по разным полям.
Структура данных представлена следующим набором полей:
```
{
"account": "234678", //long
"name": "Иванов Иван Иванович", //string
"value": "2035.34" //double
}
```
Количество записей заранее не определено и может меняться динамически.
ВОПРОС: Необходимо организовать хранение этих записей в памяти с
соблюдением требований:
1. предоставить возможность добавлять новые записи;
2. предоставить возможность удалять более не нужные записи;
3. предоставить возможность изменять запись;
4. получать полный набор записи по любому из полей с одинаковой
   алгоритмической сложностью (не медленнее log(n));
5. выбрать наиболее экономный способ хранения данных в памяти.

Важно: Нужно обосновать выбор структур данных и алгоритмов относительно требований ТЗ.
Ограничение: для реализации используйте один из указанных языков: Java,
C#, C++, Python.

### Выбор структуры данных
Для реализации хранения представленных данных в оперативной памяти выгоднее всего использовать деревья,
так как количество записей заранее неизвестно и может динамически изименяться, а также ввиду необходимости
быстрого поиска, добавления и удаления элементов. Деревья обеспечивают вставку, удаление и поиск за
O(logN). Однако несбалансированные деревья имеют свойство терять свое быстродействие, снижая поиск до
O(N) из-за вставки упорядоченных данных. Таким образом, быстродействие становится не лучше, чем у 
связанного списка. Исходя из этих соображений было принято реализовать кэш на базе красно-черных деревьев,
которые являются сбалансированными деревьями и **гарантируют** быстродействие **O(logN)** независимо
от входных данных. Единственная проблема в таком случае - это то, что в красно-черных деревьях незначительно
увеличиваются затраты по памяти на хранение логических переменных. Время вставки и удаления возрастает с
постоянным коэффициентом из-за необходимости поворотов и перекрашиваний. Однако чаще всего операции
поиска превышают по количеству операции вставки и удаления. Учитывая, что в задании не сказано конкретно
про сценарии работы с данными и точно неизвестно, поступают ли на вход случайные данные, разумнее всего использовать
именно сбалансированные деревья, если отталкиваться от наиболее частых сценариев работы с данными.
### Почему не хэш-таблицы?
Действительно, хэш-таблицы обладают самой высокой скоростью и не чувствительны к упорядоченности входных данных, но 
их использование сопряжено с излишними затратами памяти. Также объем данных должен быть относительно точно известен.
Поэтому лучшим вариантом остается сбалансированное дерево.
## Примечание
В случае если задание будет уточнено и окажется, что данные подаются случайные, и нет риска, что деревья
двоичного поиска будут вырожденены до O(N), то не составит труда реализовать хранение кэша на основе именно этой
структуры данных. 

### Класс InMemoryDB
Реализованный класс представляет собою интерфейс взаимодействия с данными, предоставляющий возможности 
добавления, изменения, удаления, просматра данных, выполнение поиска по необходимым полям и возвращения
всех записей. Данные хранятся на основе красно-черного дерева.